{"id":"node_modules/fre/dist/fre.js","dependencies":[{"name":"D:\\Users\\changhaozhao\\Desktop\\132\\fre\\demo\\node_modules\\fre\\dist\\fre.js.map","includedInParent":true,"mtime":1613640750214},{"name":"D:\\Users\\changhaozhao\\Desktop\\132\\fre\\demo\\package.json","includedInParent":true,"mtime":1616497873999},{"name":"D:\\Users\\changhaozhao\\Desktop\\132\\fre\\demo\\node_modules\\fre\\package.json","includedInParent":true,"mtime":1613640750214}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Fragment = X;\nexports.useState = exports.useRef = exports.useReducer = exports.useMemo = exports.useLayoutEffect = exports.useLayout = exports.useEffect = exports.useCallback = exports.render = exports.options = exports.h = void 0;\n\nconst e = (e, t, n) => {\n  for (let l in Object.assign(Object.assign({}, t), n)) {\n    let o = t[l],\n        r = n[l];\n    if (o === r || \"children\" === l) ;else if (\"style\" === l) for (const t in Object.assign(Object.assign({}, o), r)) o && r && o[t] === r[t] || (e[l][t] = (null == r ? void 0 : r[t]) || \"\");else \"o\" === l[0] && \"n\" === l[1] ? (l = l.slice(2).toLowerCase(), o && e.removeEventListener(l, o), e.addEventListener(l, r)) : !(l in e) || e instanceof SVGElement ? null == r || !1 === r ? e.removeAttribute(l) : e.setAttribute(l, r) : e[l] = r || \"\";\n  }\n};\n\nlet t = 0;\n\nconst n = e => l(null, e),\n      l = (e, n) => {\n  const [l, o] = a(t++);\n  return [l.length > 0 ? l[0] : n, t => {\n    l[0] = e ? e(l[0], t) : t, A(o);\n  }];\n},\n      o = (e, t) => i(e, t, \"effect\"),\n      r = (e, t) => i(e, t, \"layout\"),\n      i = (e, n, l) => {\n  const [o, r] = a(t++);\n  d(o[1], n) && (o[0] = e, o[1] = n, r.hooks[l].push(o));\n},\n      s = (e, n) => {\n  const l = a(t++)[0];\n  return d(l[1], n) ? (l[1] = n, l[0] = e()) : l[0];\n},\n      u = (e, t) => s(() => e, t),\n      c = e => s(() => ({\n  current: e\n}), []),\n      a = e => {\n  const t = F(),\n        n = t.hooks || (t.hooks = {\n    list: [],\n    effect: [],\n    layout: []\n  });\n  return e >= n.list.length && n.list.push([]), [n.list[e], t];\n},\n      d = (e, t) => !e || e.length !== t.length || t.some((t, n) => t !== e[n]),\n      f = [],\n      p = [];\n\nexports.useRef = c;\nexports.useCallback = u;\nexports.useMemo = s;\nexports.useLayoutEffect = exports.useLayout = r;\nexports.useEffect = o;\nexports.useReducer = l;\nexports.useState = n;\nlet g = 0;\n\nconst h = e => 1 === p.push(e) && y(),\n      y = (() => {\n  const e = () => p.splice(0, p.length).forEach(e => e());\n\n  if (\"undefined\" != typeof MessageChannel) {\n    const {\n      port1: t,\n      port2: n\n    } = new MessageChannel();\n    return t.onmessage = e, () => n.postMessage(null);\n  }\n\n  return () => setTimeout(e);\n})(),\n      v = () => {\n  g = m() + 1e3 / 60;\n  let e = b(f);\n\n  for (; e && !k();) {\n    const t = e.callback;\n    e.callback = null;\n    const n = t();\n    n ? e.callback = n : f.shift(), e = b(f);\n  }\n\n  e && h(v);\n},\n      k = () => {\n  var e, t;\n  return (null === (t = null === (e = navigator) || void 0 === e ? void 0 : e.scheduling) || void 0 === t ? void 0 : t.isInputPending()) || m() >= g;\n},\n      m = () => performance.now(),\n      b = e => e.sort((e, t) => e.time - t.time)[0];\n\nlet E,\n    P,\n    w = [];\n\nconst x = (e, t, n) => {\n  A({\n    node: t,\n    props: {\n      children: e\n    },\n    done: n\n  });\n},\n      A = e => {\n  e && !e.dirty && (e.dirty = !0, e.tag = 2, ((e, t) => {\n    const n = {\n      callback: e,\n      time: t\n    };\n    f.push(n), h(v);\n  })(j.bind(null, e), e.time));\n},\n      j = e => {\n  for (; e && !k();) e = C(e);\n\n  return e ? j.bind(null, e) : (E && V(E), null);\n},\n      C = e => {\n  if (K(e.type) ? L(e) : M(e), e.dirty = !e.dirty && 0, e.child) return e.child;\n\n  for (; e;) {\n    if (!E && !1 === e.dirty) return E = e, e.sibling = null, null;\n    if (e.sibling) return e.sibling;\n    e = e.parent;\n  }\n},\n      L = e => {\n  if (e.lastProps === e.props) return;\n  P = e;\n  let n = m(),\n      l = e.type(e.props);\n  e.time = m() - n, t = 0, Q(l) && (l = W(l)), N(e, l);\n},\n      M = t => {\n  t.parentNode = (e => {\n    for (; e = e.parent;) if (!K(e.type)) return e.node;\n  })(t), t.node || (t.node = (t => {\n    const n = \"text\" === t.type ? document.createTextNode(\"\") : 16 & t.tag ? document.createElementNS(\"http://www.w3.org/2000/svg\", t.type) : document.createElement(t.type);\n    return e(n, {}, t.props), n;\n  })(t)), N(t, t.props.children);\n},\n      N = (e, t) => {\n  var n, l, o;\n  let r = e.kids || [],\n      i = e.kids = I(t),\n      s = 0,\n      u = 0,\n      c = r.length - 1,\n      a = i.length - 1,\n      d = null,\n      f = Array(i.length);\n\n  for (; s <= c && u <= a;) {\n    let e = null;\n    if (null == r[s]) s++;else if (null == r[c]) c--;else if (G(r[s], i[u])) e = i[u], O(e, r[s]), e.tag = 2, f[u] = e, s++, u++;else if (G(r[c], i[a])) e = i[a], O(e, r[c]), e.tag = 2, f[a] = e, c--, a--;else if (G(r[s], i[a])) e = i[a], O(e, r[s]), e.tag = 10, e.insertPoint = r[c].node.nextSibling, f[a] = e, s++, a--;else if (G(r[c], i[u])) e = i[u], O(e, r[c]), e.tag = 10, e.insertPoint = r[s].node, f[u] = e, c--, u++;else {\n      if (!d) {\n        d = new Map();\n        let e = u;\n\n        for (; e < a;) d.set(S(i[e]), e++);\n      }\n\n      if (d.has(S(r[s]))) {\n        const t = r[d.get(r[s])];\n        e = i[u], O(e, t), e.tag = 10, r[g] = null, e.insertPoint = null === (n = r[s]) || void 0 === n ? void 0 : n.node, f[u] = e;\n      } else e = i[u], e.tag = 8, e.node = null, e.insertPoint = null === (l = r[s]) || void 0 === l ? void 0 : l.node;\n\n      u++;\n    }\n  }\n\n  const p = null === (o = f[a + 1]) || void 0 === o ? void 0 : o.node;\n\n  for (; u <= a;) {\n    let e = i[u];\n    e.tag = 8, e.node = null, e.insertPoint = p, u++;\n  }\n\n  for (; s <= c;) {\n    let e = r[s];\n    e && (e.tag = 16, w.push(e)), s++;\n  }\n\n  for (var g = 0, h = null; g < i.length; g++) {\n    const t = i[g];\n    t.parent = e, g > 0 ? h.sibling = t : e.child = t, h = t;\n  }\n};\n\nexports.render = x;\n\nfunction O(e, t) {\n  e.lastProps = t.props, e.node = t.node, e.kids = t.kids, e.hooks = t.hooks, e.ref = t.ref;\n}\n\nconst S = e => null == e ? e : e.key,\n      T = e => K(e.type) ? e.type.name : e.type,\n      V = e => {\n  var t;\n  e.parent ? B(e) : B(e.child), w.forEach(B), null === (t = e.done) || void 0 === t || t.call(e), w = [], E = null;\n},\n      B = t => {\n  if (!t) return;\n  let {\n    type: n,\n    tag: l,\n    parentNode: o,\n    node: r,\n    ref: i,\n    hooks: s\n  } = t;\n\n  if (K(n)) {\n    const e = (e => {\n      let t = e;\n\n      for (; e = e.child;) if (!K(e.type)) return e.tag |= t.tag, e.insertPoint = t.insertPoint, e;\n    })(t);\n\n    16 & t.tag ? (B(e), s && s.list.forEach(J)) : (t.node = e.node, s && (D(s.layout), h(() => D(s.effect))), B(t.child), B(t.sibling));\n  } else {\n    if (16 & l) return z(t.kids), o.removeChild(t.node), void q(i, null);\n\n    if (2 & l && e(r, t.lastProps || {}, t.props), 8 & l) {\n      const e = t.insertPoint;\n      o.insertBefore(t.node, e);\n    }\n\n    t.tag = 0, q(i, r), B(t.child), B(t.sibling);\n  }\n},\n      G = (e, t) => S(e) === S(t) && T(e) === T(t),\n      I = e => e ? Y(e) ? e : [e] : [],\n      q = (e, t) => {\n  e && (K(e) ? e(t) : e.current = t);\n},\n      z = e => {\n  e.forEach(e => {\n    e.kids && z(e.kids), q(e.ref, null);\n  });\n},\n      D = e => {\n  e.forEach(J), e.forEach(H), e.length = 0;\n},\n      F = () => P || null,\n      H = e => e[2] = e[0](),\n      J = e => e[2] && e[2](),\n      K = e => \"function\" == typeof e,\n      Q = e => \"number\" == typeof e || \"string\" == typeof e,\n      R = e => null != e && !1 !== e && !0 !== e,\n      U = function (e, t) {\n  const n = t || {},\n        l = n.key || null,\n        o = n.ref || null;\n  let r = [],\n      i = \"\";\n  const s = arguments.length;\n\n  for (let e = 2; e < s; e++) {\n    let t = arguments[e];\n    const n = e === s - 1,\n          l = R(t) ? t : \"\",\n          o = Q(l);\n\n    for (o && (i += String(l)), !i || o && !n || (r.push(W(i)), i = \"\"), o || r.push(l); r.some(e => Y(e));) r = [].concat(...r);\n  }\n\n  return r.length && (n.children = 1 === r.length ? r[0] : r), delete n.key, {\n    type: e,\n    props: n,\n    key: l,\n    ref: o\n  };\n};\n\nexports.h = U;\n\nfunction W(e) {\n  return {\n    type: \"text\",\n    props: {\n      nodeValue: e\n    }\n  };\n}\n\nfunction X(e) {\n  return e.children;\n}\n\nconst Y = Array.isArray,\n      Z = {};\nexports.options = Z;"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"241afde94f184a3e11d4dcb0d7f36991","cacheData":{"env":{}}}